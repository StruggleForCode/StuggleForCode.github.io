{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/02/05/hello-world/"},{"title":"IMUSTACM第六次集训","text":"内蒙古科技大学ACM协会第六次集训 复习1.栈特点：后进先出算法可视化：数组实现栈 链表实现栈STL中stack简单使用 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;stack&gt; //STL 库中的栈的头文件 // c++ 中才有STL库 c语言中没有using namespace std;int main(){ stack&lt;输入你想定义类型的栈&gt; s; stack&lt;int&gt; s; // 定义一个int 类型的栈 stack&lt;double&gt; s1; // 定义一个double 类型的栈 // stack&lt;node&gt; s; node 是一个结构体 s.empty() // 一般用来判断s是否为空 返回值为bool 类型 // 注：bool 类型是C++中的，c 中并没有， 它只有两个值， true 或 false s.top() // 返回栈顶元素 s.pop() // 把栈顶元素弹出 s.push() // 向栈顶压入一个元素 s.size() // 栈的大小， 一般用的比较少 while(!s.empty()){ // 将栈内的元素清空，并打印每一个元素 cout &lt;&lt; s.top() &lt;&lt; endl; s.pop(); } return 0;} 2.队列特点：先进先出算法可视化：数组实现队列 链表实现队列队列分为好多种： 普通队列 双端队列 (这里不多说，想学的下去百度,竞赛中比较常用) 优先队列 (这里不多说，想学的下去百度,竞赛中也比较常用) STL中queue简单使用 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;queue&gt; // STL中队列的头文件 普通队列和优先队列都需要这个头文件#include &lt;deque&gt; // STL中双端队列的头文件 不多讲using namespace std;int main(){ queue&lt;类型&gt; que; // 和stack 一样 queue&lt;int&gt; q; // 定义一个int 类型的栈 q.empty(); // 一般用来判断一个队列是否为空， 返回bool类型 q.front(); // 返回队列中第一个元素 q.pop(); // 把第一个元素弹出 q.push(); // 向队列的尾部插入一个元素 q.size(); // 队列的大小, 用的一般比较校 while (!q.empty()) // 将队列的元素清空，并打印每一个元素 { cout &lt;&lt; q.front() &lt;&lt; endl; q.pop(); } priority_queue&lt;类型&gt; que; //定义优先队列 //优先队列内部实现是堆数据结构实现的,有兴趣的同学可以下去看一下 que.top()//优先队列和普通队列的主要区别,返回第一个元素不同 //其他，自行百度，以后也会讲到 return 0;} 脚下留心 q.front(); 等一定要加上()，q.front; 这样是不对的。 其他 递归的内部实现就是栈个人建议粘贴代码用这个网站，然后网群里发链接。网址为：https://paste.ubuntu.com/怎么用： 开始今天的讲解1.先介绍一下基础知识 头文件 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt; //c++ 头文件#include &lt;stdio.h&gt; // c 头文件 想在C++中使用scanf必须要写这个头文件#include &lt;algorithm&gt; // c++ 头文件 very important 很多地方都要用到#include &lt;string.h&gt; // c 语言中的头文件，一般调用memset() 初始化函数的时候需要用到#include &lt;queue&gt; // 队列#include &lt;stack&gt; // 栈#include &lt;string&gt; // c++ 字符串#include &lt;vector&gt; // 数组容器 后面会讲到#include &lt;list&gt; // 链表容器#include &lt;map&gt; // 一种容器 映射 哈希#include &lt;set&gt; // 集合#include &lt;bits/stdc++.h&gt; // c++中万能头文件，一般有的判题机会卡 建议不要用using namespace std;// 定义宏, 定义宏不占用内存空间；关于宏与const区别,可以自行百度#define N 1000// 定义常量, 常量的值一般不能修改，一般用常量声明数组的大小const int N = 1000;const int inf = 0x3f3f3f3f; // 0x3f3f3f3f的十进制是1061109567， //是10^9级别的（和0x7fffffff一个数量级）， //而一般场合下的数据都是小于10^9的， //所以它可以作为无穷大使用而不致出现数据大于无穷大的情形。 //比较专业，记住就可以了int main(){ int n = 10; int a[n]; // 这样定义是错的 int a[N]; // 这样定义是正确的，常量能定义数组大小 //介绍一下memset() memset(a, 0, sizeof(a)); // 对一个数组初始化 // memset 不是万能的初始化函数 // 它只能初始化-1 0， 0x3f(初始化为0x3f3f3f3f 无穷大) memset只能对一个字节进行初始化 // 想明白他的原理，自行百度。 return 0;} c++中类的知识简单介绍 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;using namespace std;class node { private: int a, b; public: node (int _a = 0, _b = 0){ a = _a; b = _b; } //c++中构造函数 node(int _a = 0, _b = 0):a(_a), b(_b){} //构造函数简写， //和上面的功能一样，这写法程序竞赛中用的比较多}//同样c++中的结构体也有构造函数，我们一般用结构体定义类型struct node1{ int a, b; node1(int _a = 0, int _b = 0):a(_a),b(_b){} //构造函数，能直接传参}int main(){ node1 cnt; // cnt 中默认的两个cnt.a cnt.b 都为0 node1 ans(1, 2); // ans 中ans.a = 1, ans.b = 2; /* 这部分知识现阶段作为了解就可以了，以后学c++会学，如果想自学，可以百度。 */}``` #### 2.深搜(深度优先搜索)深度优先搜索，简称dfs, 是一个经典的搜索算法，现在我们把dfs和递归联系起来。前面学习递归的时候，我们用递归实现阶乘```c++int factorial(int n) { if (n == 1) { return 1; } return n * factorial(n - 1);} 和用递归实现斐波那契数列 123456int fib(int n) { if (n == 1 || n == 2) { return 1; } return fib(n - 1) + fib(n - 2);} 实际上前面的两个方法都可以称为深度优先搜索，也就是说前面学习的过程中，我们已经在无形之中使用了深度优先搜索 深度优先搜索按照深度优先的方式进行搜索，通俗点说就是“一条路走到黑”。注意，我们这里“搜索”不是指的是我们平时在文件中或者网络上查找某些信息，搜索是一种穷举方式，把所有可行的方案都列出来，不断去尝试，直到找到问题的解。深度优先搜索和递归的区别是：深度优先搜索是一种算法，注重的是思想；而递归是一种基于编程语言的实现方式。深度优先搜索可以用递归实现，也是说递归是我们计算机编程语言来实现深度优先搜索这个算法的手段。 PS：当然，我们也同样可以用非递归的方式来实现搜索(stack)。 先尝试走一个迷宫： 这是一种最短走法： 接下来，我们通过一个实际问题-迷宫游戏来学习dfs 题目：Hero In Maze 简单版 题目分析： n和m分别是长和高 如果用二维数组存，就分别是列和行。‘S’ 代表起点，’P’ 代表终点，’.’ 代表空地，’*’代表障碍。你需要从’S’出发走到’P’,每次只能上下左右相邻的位置移动，不能走出地图，也不能穿过墙壁，每个点只能通过一次。你需要来编程来求解出一种从起点到终点的走法。 迷宫解法： 迷宫问题的解法就需要用到dfs。我们对上下左右四个方向，一个方向一个方向地尝试，如果沿着某个方向不能走到终点，我们就要原路返回，继续尝试其他方向，直到走出迷宫。这是最朴素的走迷宫方式，虽然效率也许比较低，但如果迷宫有解，就一定能走出终点。上面说的这种搜索，就对应着我们要讲的dfs算法。首先找到起点’S’,走到每个点时，按照左、下、右、上的顺序尝试。每走到下一个点后，我们把这个点当做起点’S’,继续按顺序尝试。如果某个点上下左右四个方向都尝试过，便回到走到这个点之前的点，这一步我们称之为回溯。继续尝试其他方向。直到所有点都尝试过上下左右方向。这就好比你自己走这个迷宫，你也要一个方向一个方向的尝试着走，如果这条路不行，就回头，尝试下一条路，dfs的思想和我们直观的想法很类似。只不过，接下来我们需要用程序来完成这个过程。 dfs走迷宫对应的代码框架如下： 12345678910111213141516171819202122232425262728293031323334// 对坐标为 (x, y) 的点进行搜索bool dfs(int x, int y) { if (x, y) 是终点 { // 找到了路径 return true; } 标记 (x, y) 已经访问 向上走到位置 (tx, ty) if (tx, ty) 在地图里面且没有访问 { if (dfs(tx, ty) == true) { return true; } } 向左走到位置 (tx, ty) if (tx, ty) 在地图里面且没有访问 { if (dfs(tx, ty) == true) { return true; } } 向下走到位置 (tx, ty) if (tx, ty) 在地图里面且没有访问 { if (dfs(tx, ty) == true) { return true; } } 向右走到位置 (tx, ty) if (tx, ty) 在地图里面且没有访问 { if (dfs(tx, ty) == true) { return true; } } 取消 (x, y) 访问标记 return false;} 下面，我们来开始分析代码怎么写： 首先我们需要声明一些变量 12345const int MAX = 20 + 5; //定义一个常量，用来规定图的最大大小。char map[MAX][MAX];//定义字符数组来存图bool vis[MAX][MAX];//在一条路径上一个点不能重复经过，用来记录走过的点false 没走过，true走过bool ok = false; // 如果搜到终点，ok置为true,则dfs结束,剪枝操作int n, m; // 声明列和行. 上面代码框架判断有点麻烦，我们定义四个方向可以用两个数组来实现 1234567891011121314151617181920212223242526272829303132333435int dx[4] = {1, -1, 0, 0}; // 分别是 上 下， 右， 左方向int dy[4] = {0, 0, 1, -1};假设目前所在的点的坐标为(x, y)，下一步移到的位置为（tx,ty);则求下一步移到的方向的坐标我们可以用一个for循环来解决for(int i = 0; i &lt; 4; i++){ tx = x + dx[i]; ty = y + dx[i];}对于每一移到的点，我们要判断它是否“合法”“合法”需要满足几个条件，即点在地图里面，这个点在地图上不是障碍'*',这个点在这目前这条路径中没有被访问过。我们可以把上面这些判断条件封装成一个函数：bool in(int x, int y){ // x 表示行坐标，y 表示列坐标 return x &lt; 0 || x &gt;= m || y &lt; 0 || y &gt;= n || map[x][y] == '*' || vis[x][y] == true;}完整的dfs代码：void dfs(int x, int y){ if(ok) return; // 剪枝 if(map[x][y] == 'P'){ ok = true; return; } for (int i = 0; i &lt; 4; i++){ int tx = x + dx[i]; int ty = y + dy[i]; if(!in(tx, ty)){ //如果下一个点符合条件，则对下一个点进行搜索 vis[tx][ty] = true; // 对这个点标记走过 dfs(tx, ty); vis[tx][ty] = false; // 返回上一级，重新把这个点标记未走过 } }} AC代码dfs 3.广搜(广度优先搜索)广度优先搜索，又称宽度优先搜索，简称bfs。与深度优先搜索不同的是，广度优先搜索会将与起始点距离较近的点搜索完毕，再继续搜索较远的点，而深度优先搜索却是沿着一个分支搜到最后。bfs从起点开始，优先搜索离起始点最近的点，然后由这个最近的点扩展其他稍近的点，这样一层一层的扩展，就像水波散一样。 对上图进行深搜按照顶点访问顺序会得到序列：A-B-E-F-C-D-G对上图进行广搜按照顶点访问顺序会得到序列：A-B-C-D-E-F-G如果把上边的图片看成一棵树，深搜遍历就是树的前序遍历，广搜就是树的层次遍历(关于树的前序，中序，后序，层次遍历可以自己百度) 广度优先搜索的层次关系是很明显的，上面的图的分层次关系如下： 第一层的点为A 第二层的点为B,C,D 第三层的点为E,F,G bfs需要借助队列来实现：1.初始的时候把起始点放到队列中，并标记起点访问2.如果队列不为空，从队列中取出一个元素x,否则算法结束3.访问和x相连的所有点v，如果v没有被访问，把v入队，并标记已经访问。4.重复执行步骤2 最后写出代码框架如下： 1234567891011121314void bfs(起始点) { 将起始点放入队列中; 标记起点访问; while (如果队列不为空) { 访问队列中队首元素x; 删除队首元素; for (x 所有相邻点) { if (该点未被访问过且合法) { 将该点加入队列末尾; } } } 队列为空，广搜结束;} 首先我们先看一道基础广搜基础题：题目：广搜过程表 题目分析： 给你两个数代表一个二位数组的行和列，然后再给你一个起点，起点的坐标为(x, y), 然后从起点开始，对于数组中每个位置相邻的数字都加一。就是实现广搜过程。也就是说二维数组每一点对应的值，就是从原点到这一点的最小步数。 样例分析： 输入:4 42 2输出：2123101221233234 理清题目的思路，我们就可以愉快的写代码了(如果没有理清题目思路，比赛中千万不要开始写代码) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//和前面的深搜一样，我们要先定义方向数组，因为对于每个点都需要访问其上下左右四个方向。int dx[4] = {1, -1, 0, 0}; // 分别是 上 下， 右， 左方向int dy[4] = {0, 0, 1, -1};然后我们再定义一些做题需要用到的变量const int MAX = 20 + 5; //MAX 规定了数组的最大值 // MAX 一般都是题目给定最大范围+5或+10;int n, m; //定义二位数组的行和列bool vis[MAX][MAX]; //定义这个点是否加入到队列中，是否之前访问过， //如果没有这个数组，刚访问过的点会从新加入到队列中 //，这会使程序一直执行，不能中止int map[MAX][MAX]; //定义数组；我们还需要定义一个结构体，来记录坐标的行和列，还有步数struct node{ int x, y; //用来记录当前坐标点的坐标 int step; // 用来记录原点到当前坐标点的需要的步数 //C++构造中构造函数，前面我已经讲过。 node(int _x = 0, int _y = 0, int _step = 0):x(_x), y(_y), step(_step){}};此外，还需要定义一个函数，判断这个点是否合法，即判断这个点是否在这个数组中，是否在之前被访问过。//返回值如果为true, 则合法，如果为false, 则不合法bool in(int x, int y){ return x &gt;= 1 &amp;&amp; x &lt;= n &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= m &amp;&amp; !vis[x][y]; }与当前点相邻的点搞，与之前一样for(int i = 0; i &lt; 4; i++){ tx = x + dx[i]; ty = y + dx[i];}然后我们根据之前缩写的代码框架，我们就可以写出我们bfs了void bfs(int sx, int sy){ queue&lt;node&gt; que; // 创建一个类型为node的队列 que.push(node(sx, sy, 0)); // 把当前坐标点和步数压入到队列中， //因为起点到起点的步数为0，所以step = 0; vis[sx][sy] = true; // 压入一个点，标记这个点已经被访问过了 while(!que.empty()){ //如果队列不为空，就一直执行循环里的操作 node now = que.front(); //取出队列中的第一个点 que.pop();//把第一个点弹出 for (int i = 0; i &lt; 4; i++){ int tx = now.x + dx[i]; int ty = now.y + dy[i]; if(in(tx, ty)){ //如果队列中第一个顶点与其相邻的顶点合法，我们就把它压入队列 map[tx][ty] = now.step + 1; //map数组就是用来记录当前点到原点的距离 vis[tx][ty] = true; que.push(node(tx, ty, now.step + 1)); } } }} 简单的广搜过程就这样写完了，是不是很简单，放上本题的AC代码：请点我 到这里，我们广搜和深搜基本上就讲完。然后我们在看迷宫。 前面我们已经接触过了迷宫游戏，并且学会了如何使用dfs来解决迷宫最短路问题。用dfs求解迷宫最短路有一个很大的缺点，需要枚举所有可能的路径，读入的地图一旦很大，可能的搜索方案数量会非常多，用dfs搜索显然效率会很低。我们可以借助bfs来求解迷宫游戏。由于bfs是分层搜索，因此，第一次搜索到终点的时候，当前搜索的层数就是最短路径的长度 注：广搜第一个搜到的终点所经过的路径一定是最短的路径，深搜第一个搜到终点的不一定是最短的路经。 在练习一道题目：题目：Hero In Maze I 题意分析： 和前面那个深搜题描述基本一样,这道题m是列，n是行(前面那道题m是行，n是列，都一样哇！),T是时间，’.’ 代表空地，’*’代表障碍，’P’代表终点, ‘S’, 代表起点。每次只能往上、下、左、右四个方向走, 每走一步花费一个单位时间。 解题分析： 我们需要求英雄是否能在规定的时间内救下公主，转换一下就是求英雄救下公主所需要的最短时间。我们用之前的深搜可能也能解决上述问题(如果题目的范围比较小的话),如果题目范围比较大，我们必须用广搜。如果题目范围是50以内，我们可以用深搜，，如果题目范围是1000甚至上万，我们就需要用到广搜了。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//和前面的深搜一样，我们要先定义方向数组，因为对于每个点都需要访问其上下左右四个方向。int dx[4] = {1, -1, 0, 0}; // 分别是 上 下， 右， 左方向int dy[4] = {0, 0, 1, -1};接下来定义一些常量和变量。const int MAX = 200 + 5; //定义一个常量，用来规定图的最大大小。char map[MAX][MAX];//定义字符数组来存图bool vis[MAX][MAX];//在一条路径上一个点不能重复经过。int n, m, t; // n 表示行， m 表示列//定义结构体，和前面的广度搜索表一样。struct node{ int x, y; int step; // 用于记录步数 node(int _x = 0, int _y = 0, int _step = 0): x(_x), y(_y), step(_step){}};判断点是否“合法”性bool in(int x, int y){ // x 表示行坐标，y 表示列坐标 return x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= m || map[x][y] == '*' || vis[x][y];}完整BFS代码：bool bfs(int x, int y){ queue&lt;node&gt; que; que.push(node(x, y, 0)); vis[x][y] = true; while(!que.empty()){ node now = que.front(); que.pop(); if(map[now.x][now.y] == 'P'){ if(now.step &lt;= t) return true; //如果走到'P'点的花费小于t 则能成功救出公主，返回true,否则返回false; else return false; } for (int i = 0; i &lt; 4; i++){ int tx = now.x + dx[i]; int ty = now.y + dy[i]; if(!in(tx, ty)){ vis[tx][ty] = true; que.push(node(tx, ty, now.step + 1)); } } } return false;} AC代码","link":"/2020/02/06/IMUSTACM%E7%AC%AC%E5%85%AD%E6%AC%A1%E9%9B%86%E8%AE%AD/"}],"tags":[],"categories":[]}